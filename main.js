/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BlockReorderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var BlockReorderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.draggingElement = null;
    this.dragStartY = 0;
  }
  async onload() {
    console.log("Loading Block Reorder plugin");
    this.dragHandle = document.createElement("div");
    this.dragHandle.addClass("block-drag-handle");
    this.dragHandle.innerHTML = "\u22EE\u22EE";
    document.body.appendChild(this.dragHandle);
    this.registerDomEvent(document, "mouseover", this.onMouseOver.bind(this));
    this.registerDomEvent(document, "mouseout", this.onMouseOut.bind(this));
    this.registerDomEvent(this.dragHandle, "mousedown", this.onDragStart.bind(this));
    this.registerDomEvent(document, "mousemove", this.onDragMove.bind(this));
    this.registerDomEvent(document, "mouseup", this.onDragEnd.bind(this));
    console.log("Block Reorder plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Block Reorder plugin");
    this.dragHandle.remove();
  }
  onMouseOver(event) {
    const target = event.target;
    if (target.matches(".cm-line")) {
      this.showDragHandle(target);
    }
  }
  onMouseOut(event) {
    const relatedTarget = event.relatedTarget;
    if (relatedTarget !== this.dragHandle && !(relatedTarget == null ? void 0 : relatedTarget.closest(".block-drag-handle"))) {
      this.hideDragHandle();
    }
  }
  showDragHandle(target) {
    const rect = target.getBoundingClientRect();
    this.dragHandle.style.display = "block";
    this.dragHandle.style.top = `${rect.top + window.scrollY}px`;
    this.dragHandle.style.left = `${rect.left + window.scrollX - 20}px`;
  }
  hideDragHandle() {
    this.dragHandle.style.display = "none";
  }
  onDragStart(event) {
    const lineElement = this.getLineElementFromPoint(event.clientX, event.clientY);
    if (lineElement) {
      this.draggingElement = lineElement;
      this.dragStartY = event.clientY;
      event.preventDefault();
    }
  }
  onDragMove(event) {
    var _a, _b;
    if (this.draggingElement) {
      const hoverElement = this.getLineElementFromPoint(event.clientX, event.clientY);
      if (hoverElement && hoverElement !== this.draggingElement) {
        const rect = hoverElement.getBoundingClientRect();
        if (event.clientY < rect.top + rect.height / 2) {
          (_a = hoverElement.parentNode) == null ? void 0 : _a.insertBefore(this.draggingElement, hoverElement);
        } else {
          (_b = hoverElement.parentNode) == null ? void 0 : _b.insertBefore(this.draggingElement, hoverElement.nextElementSibling);
        }
      }
    }
  }
  onDragEnd() {
    if (this.draggingElement) {
      this.updateEditorContent();
      this.draggingElement = null;
    }
  }
  getLineElementFromPoint(x, y) {
    const element = document.elementFromPoint(x, y);
    return element ? element.closest(".cm-line") : null;
  }
  updateEditorContent() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      const editor = view.editor;
      const content = Array.from(document.querySelectorAll(".cm-line")).map((line) => line.innerText).join("\n");
      editor.setValue(content);
    }
  }
};
