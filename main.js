/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DragAndDropBlocksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/DragVisuals/DragVisuals.ts
var import_obsidian = require("obsidian");

// src/DragVisuals/DragPlaceholder.ts
var DragPlaceholder = class {
  constructor() {
    this.currentPosition = null;
    this.targetLine = null;
    this.sourceLineNumber = null;
    this.element = this.createDragPlaceholderElement();
    document.body.appendChild(this.element);
  }
  createDragPlaceholderElement() {
    const dragPlaceholder = document.createElement("div");
    dragPlaceholder.className = "drag-placeholder";
    return dragPlaceholder;
  }
  getFrontmatterLineCount(doc) {
    let lineCount = 0;
    const firstLine = doc.line(1);
    if (firstLine.text.trim() !== "---") {
      return 0;
    }
    for (let i = 2; i <= doc.lines; i++) {
      lineCount++;
      const line = doc.line(i);
      if (line.text.trim() === "---") {
        return lineCount + 1;
      }
    }
    return 0;
  }
  showDragPlaceholder(view, pos, sourceLineNumber) {
    const doc = view.state.doc;
    const frontmatterLineCount = this.getFrontmatterLineCount(doc);
    const firstContentLineNumber = frontmatterLineCount + 1;
    const line = doc.lineAt(pos);
    let placeholderPos;
    let targetLineNumber;
    if (line.number < firstContentLineNumber) {
      placeholderPos = doc.line(firstContentLineNumber).from;
      targetLineNumber = firstContentLineNumber;
    } else if (pos >= doc.length) {
      placeholderPos = doc.length;
      targetLineNumber = doc.lines + 1;
    } else if (pos <= line.from + (line.to - line.from) / 2) {
      placeholderPos = line.from;
      targetLineNumber = line.number;
    } else {
      placeholderPos = line.to + 1;
      targetLineNumber = line.number + 1;
    }
    const rect = view.coordsAtPos(placeholderPos);
    if (!rect)
      return;
    const lineElement = view.dom.querySelector(".cm-line");
    if (!lineElement)
      return;
    const lineRect = lineElement.getBoundingClientRect();
    this.element.classList.add("drag-placeholder-visible");
    this.element.style.setProperty("--left", `${lineRect.left}px`);
    this.element.style.setProperty("--width", `${lineRect.width}px`);
    if (targetLineNumber === firstContentLineNumber) {
      const firstContentLineRect = view.coordsAtPos(placeholderPos);
      if (firstContentLineRect) {
        this.element.style.setProperty("--top", `${firstContentLineRect.top - 5}px`);
      }
    } else if (targetLineNumber > doc.lines) {
      this.element.style.setProperty("--top", `${rect.bottom + 2}px`);
    } else {
      const currentLineRect = view.coordsAtPos(line.from);
      const nextLineRect = view.coordsAtPos(doc.line(targetLineNumber).from);
      if (currentLineRect && nextLineRect) {
        this.element.style.setProperty("--top", `${(currentLineRect.bottom + nextLineRect.top) / 2}px`);
      }
    }
    this.currentPosition = placeholderPos;
    this.targetLine = targetLineNumber;
    this.sourceLineNumber = sourceLineNumber;
  }
  hideDragPlaceholder() {
    this.element.classList.remove("drag-placeholder-visible");
    this.currentPosition = null;
    this.targetLine = null;
    this.sourceLineNumber = null;
  }
  getPlaceholderPosition() {
    return this.currentPosition;
  }
  getTargetLine() {
    return this.targetLine;
  }
  getSourceLineNumber() {
    return this.sourceLineNumber;
  }
};

// src/DragVisuals/DragHandleManager.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var DragHandleWidget = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-drag-handler-container";
    span.setAttribute("draggable", "true");
    span.setAttribute("contenteditable", "false");
    span.innerHTML = `
            <span class="clickable-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-grip-vertical">
                    <circle cx="9" cy="12" r="1"></circle>
                    <circle cx="9" cy="5" r="1"></circle>
                    <circle cx="9" cy="19" r="1"></circle>
                    <circle cx="15" cy="12" r="1"></circle>
                    <circle cx="15" cy="5" r="1"></circle>
                    <circle cx="15" cy="19" r="1"></circle>
                </svg>
            </span>
        `;
    return span;
  }
};
var addDragHandle = import_state.StateEffect.define();
var setDraggingLine = import_state.StateEffect.define();
var dragHandleField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(handles, tr) {
    handles = handles.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(addDragHandle)) {
        handles = handles.update({
          add: [import_view.Decoration.widget({
            widget: new DragHandleWidget(),
            side: -1
          }).range(e.value.from)]
        });
      }
    }
    return handles;
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
var draggingLineField = import_state.StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let e of tr.effects) {
      if (e.is(setDraggingLine)) {
        return e.value;
      }
    }
    return value;
  },
  provide: (f) => import_view.EditorView.decorations.from(f, (value) => {
    return (view) => {
      if (value === null)
        return import_view.Decoration.none;
      let line = view.state.doc.line(value);
      return import_view.Decoration.set(import_view.Decoration.line({ class: "cm-dragging-line" }).range(line.from));
    };
  })
});
var dragHandlePlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.createDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.createDecorations(update.view);
    }
  }
  createDecorations(view) {
    let widgets = [];
    for (let { from, to } of view.visibleRanges) {
      for (let pos = from; pos <= to; ) {
        let line = view.state.doc.lineAt(pos);
        widgets.push(import_view.Decoration.widget({
          widget: new DragHandleWidget(),
          side: -1
        }).range(line.from));
        pos = line.to + 1;
      }
    }
    return import_view.Decoration.set(widgets);
  }
}, {
  decorations: (v) => v.decorations
});

// src/DragVisuals/DragVisuals.ts
var DragVisuals = class {
  constructor(app) {
    this.app = app;
    this.dragPlaceholder = new DragPlaceholder();
  }
  showDragPlaceholder(view, pos, sourceLineNumber) {
    this.dragPlaceholder.showDragPlaceholder(view, pos, sourceLineNumber);
  }
  hideDragPlaceholder() {
    this.dragPlaceholder.hideDragPlaceholder();
  }
  createDragPreview(text, event) {
    var _a;
    const dragImage = document.createElement("div");
    dragImage.textContent = text.slice(0, 20) + "...";
    dragImage.className = "drag-preview";
    document.body.appendChild(dragImage);
    (_a = event.dataTransfer) == null ? void 0 : _a.setDragImage(dragImage, 0, 0);
    setTimeout(() => document.body.removeChild(dragImage), 0);
  }
  getEditorView() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return null;
    return view.editor.cm;
  }
  setDraggingLine(view, lineNumber) {
    view.dispatch({
      effects: setDraggingLine.of(lineNumber)
    });
  }
  static getDragExtensions() {
    return [
      dragHandleField,
      draggingLineField,
      dragHandlePlugin
    ];
  }
  getPlaceholderPosition() {
    return this.dragPlaceholder.getPlaceholderPosition();
  }
  getTargetLine() {
    return this.dragPlaceholder.getTargetLine();
  }
  getSourceLineNumber() {
    return this.dragPlaceholder.getSourceLineNumber();
  }
};

// src/BlockMover.ts
var import_state2 = require("@codemirror/state");
var BlockMover = class {
  static moveBlock(view, fromLine, toLine) {
    const doc = view.state.doc;
    const totalLines = doc.lines;
    fromLine = Math.max(1, Math.min(fromLine, totalLines));
    toLine = Math.max(1, Math.min(toLine, totalLines + 1));
    if (toLine === fromLine + 1 || fromLine === toLine) {
      return;
    }
    const fromLineContent = doc.line(fromLine);
    const lineContent = fromLineContent.text;
    let changes = [];
    let insertPos;
    let newCursorPos;
    if (toLine > fromLine) {
      if (toLine > totalLines) {
        const lastLine = doc.line(totalLines);
        insertPos = lastLine.to;
        changes = [
          { from: insertPos, insert: "\n" + lineContent },
          { from: fromLineContent.from, to: fromLineContent.to + (fromLine === totalLines ? 0 : 1), insert: "" }
        ];
        newCursorPos = insertPos + lineContent.length + 1;
      } else {
        const targetLine = doc.line(toLine - 1);
        insertPos = targetLine.to;
        changes = [
          { from: insertPos, insert: "\n" + lineContent },
          { from: fromLineContent.from, to: fromLineContent.to + 1, insert: "" }
        ];
        newCursorPos = insertPos + lineContent.length + 1;
      }
    } else {
      const targetLine = doc.line(toLine - 1);
      insertPos = targetLine.to;
      if (fromLine === totalLines) {
        const secondLastLine = doc.line(totalLines - 1);
        changes = [
          { from: insertPos, insert: "\n" + lineContent },
          { from: secondLastLine.to, to: doc.length }
        ];
      } else {
        changes = [
          { from: insertPos, insert: "\n" + lineContent },
          { from: fromLineContent.from, to: fromLineContent.to + 1, insert: "" }
        ];
      }
      newCursorPos = insertPos + lineContent.length + 1;
    }
    try {
      view.dispatch({
        changes,
        selection: import_state2.EditorSelection.cursor(Math.min(newCursorPos, doc.length))
      });
    } catch (error) {
    }
  }
};

// src/utils.ts
var import_obsidian2 = require("obsidian");
function getEditorView(app) {
  const view = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
  if (!view)
    return null;
  return view.editor.cm;
}

// main.ts
var DragAndDropBlocksPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.draggingStartPos = null;
    this.sourceLineNumber = null;
  }
  async onload() {
    this.dragVisuals = new DragVisuals(this.app);
    this.registerEditorExtension([
      dragHandleField,
      draggingLineField,
      dragHandlePlugin,
      ...DragVisuals.getDragExtensions()
    ]);
    this.addDragAndDropListeners();
  }
  onunload() {
  }
  addDragAndDropListeners() {
    this.registerDomEvent(document, "dragstart", this.onDragStart.bind(this));
    this.registerDomEvent(document, "dragover", this.onDragOver.bind(this));
    this.registerDomEvent(document, "drop", this.onDrop.bind(this));
    this.registerDomEvent(document, "dragend", this.onDragEnd.bind(this));
  }
  onDragStart(event) {
    console.clear();
    const target = event.target;
    if (!target.classList.contains("cm-drag-handler-container"))
      return;
    const view = getEditorView(this.app);
    if (!view)
      return;
    const pos = view.posAtDOM(target);
    if (pos === null)
      return;
    const line = view.state.doc.lineAt(pos);
    this.draggingStartPos = line.from;
    this.sourceLineNumber = line.number;
    event.dataTransfer.effectAllowed = "move";
    this.dragVisuals.createDragPreview(line.text, event);
    this.dragVisuals.setDraggingLine(view, line.number);
  }
  onDragOver(event) {
    event.preventDefault();
    const view = getEditorView(this.app);
    if (!view || this.sourceLineNumber === null)
      return;
    const pos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (pos === null)
      return;
    this.dragVisuals.showDragPlaceholder(view, pos, this.sourceLineNumber);
  }
  onDrop(event) {
    event.preventDefault();
    const view = getEditorView(this.app);
    if (!view) {
      return;
    }
    const targetLine = this.dragVisuals.getTargetLine();
    const sourceLineNumber = this.dragVisuals.getSourceLineNumber();
    if (targetLine === null || sourceLineNumber === null) {
      return;
    }
    if (sourceLineNumber !== targetLine && targetLine !== sourceLineNumber + 1) {
      BlockMover.moveBlock(view, sourceLineNumber, targetLine);
    }
    this.dragVisuals.hideDragPlaceholder();
    this.dragVisuals.setDraggingLine(view, null);
  }
  getFrontmatterEndPosition(doc) {
    const firstLine = doc.line(1);
    if (firstLine.text.trim() !== "---") {
      return 0;
    }
    for (let i = 2; i <= doc.lines; i++) {
      const line = doc.line(i);
      if (line.text.trim() === "---") {
        return line.to;
      }
    }
    return 0;
  }
  shouldInsertBefore(view, pos) {
    const line = view.state.doc.lineAt(pos);
    const lineStart = line.from;
    const lineMiddle = lineStart + Math.floor(line.length / 2);
    return pos < lineMiddle;
  }
  onDragEnd(event) {
    const view = getEditorView(this.app);
    if (!view)
      return;
    this.dragVisuals.hideDragPlaceholder();
    this.dragVisuals.setDraggingLine(view, null);
    this.draggingStartPos = null;
  }
};
